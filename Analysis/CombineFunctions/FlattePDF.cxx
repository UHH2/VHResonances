/*****************************************************************************
* Project: RooFit                                                           *
*                                                                           *
* This code was autogenerated by RooClassFactory                            *
*****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "HiggsAnalysis/CombinedLimit/interface/FlattePDF.hpp"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

ClassImp(FlattePDF)

FlattePDF::FlattePDF(const char *name, const char *title, RooAbsReal& _x, RooAbsReal& _mean, RooAbsReal& _gpi, RooAbsReal& _gk, RooAbsReal& _m0) :
RooAbsPdf(name,title), x("x","x",this,_x), mean("mean","mean",this,_mean), gpi("gpi","gpi",this,_gpi), gk("gk","gk",this,_gk), m0("m0","m0",this,_m0) {}

FlattePDF::FlattePDF(const FlattePDF& other, const char* name) :  RooAbsPdf(other,name),
x("x",this,other.x), mean("mean",this,other.mean), gpi("gpi",this,other.gpi), gk("gk",this,other.gk), m0("m0",this,other.m0) {}


Double_t FlattePDF::evaluate() const {

  // Use the definition from phipi BAD: 1268  for PDF = |A^2|, where
  // A is a complex amplitude.
  Double_t mr2 = mean*mean;
  Double_t x2 = x*x;
  Double_t m02 = m0*m0;
  Double_t dm = mr2-x2;
  Double_t fact_kk(0.0);
  Double_t Gamma_pipi = gpi*gpi;
  Double_t Gamma_kk   = gk*sqrt(fabs(x2/4.0 - m02));
  if(x > 2.0*m0) { // above production threshold for KK
    fact_kk = mr2*(Gamma_kk+Gamma_pipi)*(Gamma_kk+Gamma_pipi);
  } else { // below production threshold for KK
    //    Gamma_kk = gk*sqrt(m02/4.0 - x2); // imaginary width below threshold
    fact_kk = mr2*(Gamma_kk*Gamma_kk + Gamma_pipi+Gamma_pipi);
  }

  Double_t pdf(0.0);
  if((dm*dm + fact_kk) != 0.0) {
    pdf = mr2*Gamma_kk*Gamma_pipi / (dm*dm + fact_kk);
  }

  /*
  * calculate the phase space supression factor (leaving off constant normalization term of a half)
  * to avoid problems with self normalization of the PDF.
  */
  if(x2 - 4*m02 >0)  pdf *= sqrt(x2 - 4*m02)  ;
  else pdf = 0;

  //  cout << x << " " << pdf << " " << dm << " " << fact_kk << " " << dm*dm + fact_kk << " " <<  Gamma_kk << endl;
  return pdf;
}
